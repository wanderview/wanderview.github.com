<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.4.0 -->
<title>Firefox 52 setTimeout() Changes | wanderview</title>
<meta name="generator" content="Jekyll v3.7.3" />
<meta property="og:title" content="Firefox 52 setTimeout() Changes" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Firefox 52 hit the release channel last week and includes a few changes to setTimeout() and setInterval()." />
<meta property="og:description" content="Firefox 52 hit the release channel last week and includes a few changes to setTimeout() and setInterval()." />
<link rel="canonical" href="http://localhost:4000/blog/2017/03/13/firefox-52-settimeout-changes.html" />
<meta property="og:url" content="http://localhost:4000/blog/2017/03/13/firefox-52-settimeout-changes.html" />
<meta property="og:site_name" content="wanderview" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-03-13T09:30:00-04:00" />
<script type="application/ld+json">
{"description":"Firefox 52 hit the release channel last week and includes a few changes to setTimeout() and setInterval().","@type":"BlogPosting","url":"http://localhost:4000/blog/2017/03/13/firefox-52-settimeout-changes.html","headline":"Firefox 52 setTimeout() Changes","dateModified":"2017-03-13T09:30:00-04:00","datePublished":"2017-03-13T09:30:00-04:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/blog/2017/03/13/firefox-52-settimeout-changes.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="wanderview" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">wanderview</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
              <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
              <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/archive.html">Archive</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Firefox 52 setTimeout() Changes</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2017-03-13T09:30:00-04:00" itemprop="datePublished">Mar 13, 2017
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>Firefox 52 hit the release channel last week and it includes a few <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1300659">changes to
<code class="highlighter-rouge">setTimeout()</code> and <code class="highlighter-rouge">setInterval()</code></a>.  In particular, we have changed how we
schedule and execute timer callbacks in order to reduce the possibility of
jank.</p>

<!-- more -->

<p>To start, consider the following simple demo site (you may not want to run
it yourself):</p>

<p><a href="https://people-mozilla.org/~bkelly/timer-flood/index.html">Demo Site</a></p>

<p>When you click the “Start” button the site will begin flooding the browser
with <code class="highlighter-rouge">setTimeout()</code> calls.  Each callback will call <code class="highlighter-rouge">setTimeout()</code> twice.
This results in an exponential explosion of timers.  Clicking “Stop” will
cause the timers to stop calling <code class="highlighter-rouge">setTimeout()</code>.</p>

<p>The animated GIF is there so that you can visually see if any jank occurs.
(This is a great technique I am stealing from <a href="https://twitter.com/nolanlawson">Nolan Lawson</a>’s <a href="https://nolanlawson.com/2015/09/29/indexeddb-websql-localstorage-what-blocks-the-dom/">IDB
performance post</a>).</p>

<p>Traditionally, browsers will begin dropping frames when this sort of thing
happens and the GIF will stop animating.  For example, this video shows
Firefox 45 ESR running the demo:</p>

<video src="/videos/timer-flood-45esr.mp4" controls="" width="80%" class="center-block"></video>

<p>In Firefox 52, however, we have made changes which allows the browser to
mostly survive this use case.  This video shows that, while there is a
brief pause, the animated GIF continues to play fairly smoothly in spite
of the timer flood.</p>

<video src="/videos/timer-flood-52.mp4" controls="" width="80%" class="center-block"></video>

<h2 id="how-does-it-work">How Does It Work?</h2>

<p>Firefox achieves this by implementing <strong>yielding</strong> between timer callbacks.
After a timer callback is executed we allow any other non-timer event pending
in the queue to complete before running the next timer callback.</p>

<p>For example, consider the case where we have a number of timer callbacks that
want to run at the same time as a vsync refresh.  Its a bit of a race which
events will get to run first.  The refresh, however, is often considered more
important because if it’s delayed then the site’s frame-per-second will drop.</p>

<p>With this in mind, consider the “best” case and “worst” case for scheduling
the events:</p>

<p><img src="/images/event-queue-flood.svg" width="100%" class="center-block" /></p>

<p>In the best case the refresh runs first and is not delayed.  In the worst
case the refresh is delayed until all the timer callbacks have executed.  In
extreme cases, like the demo above, this delay can be quite long.</p>

<p>Yielding between timer callbacks changes the situation so that the worst case
looks like this instead:</p>

<p><img src="/images/event-queue-yielding-effect.svg" width="100%" class="center-block" /></p>

<p>Now, the refresh will be delayed by at most one timer callback.</p>

<p>In reality we don’t actually re-arrange events in the event queue.  Perhaps
a better way to think of it is that timers are stored in a separate queue.
Only a single timer is allowed to be scheduled on the main event queue at
any time.</p>

<p><img src="/images/event-queue-yielding-timer-queue.svg" width="100%" class="center-block" /></p>

<p>So after “callback 1” completes here “callback 2” will be placed on the
main event queue at the end.  This allows the refresh event to execute next.</p>

<h2 id="is-this-throttling">Is This Throttling?</h2>

<p>No.  Typically “timer throttling” means introducing some amount of delay
into each timer.  For example, if you call <code class="highlighter-rouge">setTimeout(func, 5)</code> in a
background tab most browsers will delay the timer callback for at least
one second.</p>

<p>Yielding is different in that it allows timers to run at <strong>full speed</strong> if
the main thread is idle.  Yielding only causes timers to be delayed if the
main thread is busy.  (Of course, if the main thread is busy then timers
have always run the risk of being delayed.)</p>

<p>That being said, if we detect that the timer queue is backing up we do
begin throttling timers.  This backpressure helps avoid exhausting memory
when a script is generating more <code class="highlighter-rouge">setTimeout()</code> calls than can be executed.
This back pressure is tuned to only trigger in extreme cases and most sites
should not experience it.</p>

<h2 id="is-this-prioritization">Is This Prioritization?</h2>

<p>Again, no.  Timer yielding is not quite the same as using a priority queue
and marking timer callbacks low priority.  In a strict prioritization scheme
it would be possible for low priority events to never run.  That is not the
case here.</p>

<p>In our timer yielding approach the next timer callback is run at the same
priority as all other events.  It may execute before other work.  It is
also guaranteed to be executed at some point.</p>

<h2 id="whats-the-catch">What’s The Catch?</h2>

<p>While our general approach is to yield between timers, our end solution
doesn’t actually do that.  We actually allow a limited number of timer
callbacks to run without yielding.  We do this to mitigate impact to
sites that use timers while saturating the main thread.</p>

<p>For example, consider a site that is:</p>

<ol>
  <li>Running an animation through a large number of timer callbacks.</li>
  <li>The animation is saturating the main thread with painting.</li>
</ol>

<p>In this case the timer callbacks will be throttled by the rate at which
the paints can happen.  When the browser cannot execute the paints at
60 FPS, then you will get at most one timer callback between each refresh
driver event.</p>

<p><img src="/images/event-queue-expensive-paint.svg" width="100%" class="center-block" /></p>

<p>This is not a problem for “closed loop” animations where you measure how long
things are taking to run and adjust your changes to match.  It can, however,
dramatically increase the overall animation time for “open loop” animations.</p>

<p>For example, consider this animation demonstration site:</p>

<p><a href="https://mozdevs.github.io/servo-experiments/experiments/tiles/">“Open Loop” Animation Demo</a></p>

<p>Here the site pre-computes all the animation steps and schedules a separate
<code class="highlighter-rouge">setTimeout()</code> for each one.  Each timer callback simply modifies the DOM
for its step without measuring to see if the animation is behind.</p>

<p>This demo site will cause pretty much every modern browser to drop to zero
frames-per-second.  The total animation, however, will run quite quickly.</p>

<video src="/videos/open-loop-animation-45.mp4" controls="" width="80%" class="center-block"></video>

<p>In Firefox 52, however, we end up delaying many of the timers due
to our yielding.  This keeps the browser running at 30fps, but the animation
takes much longer to complete:</p>

<video src="/videos/open-loop-animation-52.mp4" controls="" width="80%" class="center-block"></video>

<p>This is an extreme case that we don’t think reflects the typical behavior on
most sites.  There are many ways to implement this animation without scheduling
hundreds or thousands of simultaneous timers.  Its very likely that sites are
using these alternate methods to avoid triggering the poor FPS performance caused
by this technique.</p>

<p>That being said, we still want to avoid breaking existing sites if we can.  This
is why we are not enforcing a strict yield after every timer callback.  We hope
that by allowing a few timer callbacks to run without yielding we can mitigate
the impact to these kinds of workloads while still improving performance on
sites in general.</p>

<h2 id="whats-next">What’s Next?</h2>

<p>These <code class="highlighter-rouge">setTimeout()</code> changes have just hit our release channel with Firefox 52.
We will be on the look-out for any compatibility problems in the wild.  So
far we have only had a <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1342854">single bug report</a> in the four months since this
landed in nightly.</p>

<p>If you believe you have a problem on your site in Firefox due to these changes
please <a href="https://bugzilla.mozilla.org/enter_bug.cgi?format=guided#h=dupes|Core|DOM">file a bug</a> and <a href="https://bugzilla.mozilla.org/user_profile?login=bkelly%40mozilla.com">add me to the CC list</a>.</p>

<p>Barring large-scale problems we plan to continue refining this approach.  We will
likely change our limit on “timers allowed before yielding” to use a
time budget approach instead of a fixed number.  In addition, the <a href="https://billmccloskey.wordpress.com/2016/10/27/mozillas-quantum-project/">Quantum DOM</a>
project will be experimenting with more changes to event queue scheduling in
general.</p>

<h2 id="update-3302018">Update (3/30/2018)</h2>

<p>NOTE: We implemented a time budget approach to yielding in <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1343912">Firefox 55</a>.  By
default Firefox will now execute consecutive timers for up to 4ms before forcing
a yield.</p>


  </div><a class="u-url" href="/blog/2017/03/13/firefox-52-settimeout-changes.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">wanderview</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">wanderview</li><li><a class="u-email" href="mailto:ben@wanderview.com">ben@wanderview.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/wanderview"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">wanderview</span></a></li><li><a href="https://toot.cafe/@wanderview"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#mastodon"></use></svg> <span class="username">wanderview</span></a></li><li><a href="/feed.xml"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#rss"></use></svg> <span>subscribe</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>My name is Ben Kelly.  I&#39;m a software engineer working on the DOM team at Mozilla.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
